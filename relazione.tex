\documentclass[11pt, a4paper, left=3.5cm, right=3.5cm]{article} 
\usepackage{graphicx} 
\usepackage{amsmath}
\usepackage{color}
\usepackage{courier}
\usepackage{geometry}
\graphicspath{{images/}} 
\title{Simulazione dell'evoluzione di una pandemia sulla base del modello SIR}
\author{Matilda Pasquini e Silvia Vicentini}
\begin{document}
\maketitle

\section{Cenni teorici}
Il programma \`{e} stato sviluppato col fine di simulare la diffuzione di 
un'epidemia sulla base del modello teorico SIR. Data una popolazione chiusa di 
$N$ abitanti, questi vengono suddivisi in
\begin{itemize}
\item $S$, i \textit{Suscettibili}, cio\`{e} coloro che possono essere contagiati
\item $I$, gli \textit{Infetti}, cio\`{e} coloro che possono trasmettere la malattia
\item $R$, i \textit{Rimossi}, cio\`{e} coloro che sono guariti o morti
\end{itemize}
Vale dunque la relazione $S+R+I=N$ dal momento che le morti per malattia sono 
incluse nella categoria R e le nascite o le morti per altre cause non vengono 
tenute in considerazione. Chi fa parte della categoria S pu\`{o} solo spostarsi 
nella I, parallelamente, chi nella I pu\`{o} solamente muoversi nel gruppo R. 
Questo perch\'e ogni individuo pu\`{o} essere infettato dall'agente patogeno 
non pi\`{u} di una volta, per poi diventare immune o morire. Dato che i valori 
$S$, $I$, $R$ rappresentano il numero di abitanti per ciascun insieme 
\[S, I, R \in \mathbb{N}\]
Lo spargimento dell'agente patogeno dipende da due fattori:
\begin{itemize}
\item \textit{$\beta$}, il tasso di contagio, ovvero la probabilit\`{a} di
essere contagiati
\item \textit{$\gamma$}, il tasso di guarigione, ovvero la probabilit\`{a} di 
guarire
\end{itemize}
In quanto rappresentano due probabilit\`{a}, devono valere le relazioni $\beta \in [0, 1]$ e $\gamma \in [0, 1]$.

La variazione del numero di individui all'interno di ciascuno dei tre 
raggruppamenti \`{e} definita dalle seguenti leggi differenziali
\begin{align*} 
\frac{dS}{dt} &= -\beta\frac{S}{N}I  \\
\frac{dI}{dt} &= \beta\frac{S}{N}I-\gamma I \\
\frac{dR}{dt} &= \gamma I 
\end{align*}
L'epidemia \`{e} in espansione a condizione che $\frac{dI}{dt} > 0$. 
Dato che \[\frac{dI}{dt}=(\beta\frac{S}{N}-\gamma) I>0\] 
allora $\frac{\beta}{\gamma}>\frac{N}{S}$. Poich\`{e} all'inizio dell'epidemia 
$S\approx N$, la malattia si diffonde solo se \`{e} verificata la condizione 
che il rapporto $r_0=\frac{\beta}{\gamma}>1$. \\

Discretizzando le tre leggi e studiando la variazione di individui in ciascun 
gruppo in un arco temporale $\Delta t=1$ giorno, si ottengono le seguenti formule
\begin{equation}
\begin{align*} 
S_i &= S_{i-1} - \beta \frac{S_{i-1}}{N} I_{i-1} \\
I_i &= I_{i-1} + \beta \frac{S_{i-1}}{N} I_{i-1} - \gamma I_{i-1} \\
R_i &= R_{i-1} + \gamma I_{i-1} 
\end{align*}
\end{equation}
Il progetto si sviluppa a partire da queste equazioni.
Tale modello teorico apporta notevoli semplificazioni alla reale 
diffusione di un'epidemia, nonostante ci\`{o}, esso consente di trattare 
l'andamento generale del problema in maniera semplice e chiara.

\section{Struttura del programma}
Il progetto \`{e} organizzato nei seguenti files 
\begin{itemize}
\item \textit{epidemic.hpp}, un header file, contenente le definizioni di classe e le dichiarazioni delle funzioni membro 
\item \textit{epidemic.cpp}, un source file, dove si trovano le definizioni delle funzioni membro
\item \textit{epidemic.test.cpp}, l'unit test, che consente di eseguire i test
\item \textit{main.cpp}, per testare direttamente l'implementazione del programma
\item \textit{CMake}, per semplificare la compilazione del progetto dato che è costituito da pi\`{u} di un file sorgente
\item \textit{doctest.h}, necessario per poter eseguire i test scritti in 
\textit{epidemic.test.cpp}
\item \textit{.clang-format}, per formattare il programma
%forse dovrò aggiungere un file per la libreria grafica
\end{itemize}


\subsection{epidemic.hpp}
Il file \textit{epidemic.hpp} è un hearder file contenente le definizioni delle classi e le dichiarazioni delle funzioni membro. Qui vengono \textcolor{red}{definite una struttura chiamata \textbf{\texttt{Population}} e una classe} di nome \textbf{\texttt{Epidemic}}, la struttura rappresenta una popolazione suddivisa in tre gruppi: $S$, $I$ e $R$. Il numero di persone per ogni gruppo è espresso da una variabile intera all'interno della struttura. Le componenti della classe sono elencate di seguito. \\

\textbf{\texttt{double const beta\_}} \`{e} una variabile membro costante di tipo double presente nella parte privata della classe, chiamata \textbf{\texttt{beta\_}}. Essa esprime la probabilit\`{a} di trasmissione della malattia. \\

\textbf{\texttt{double const gamma\_}} \`{e} una variabile membro costante di tipo double presente nella parte privata della classe, chiamata \textbf{\texttt{gamma\_}}. Questa indica la probabilit\`{a} di guarigione dell'epidemia in esame. \\

\textbf{\texttt{std::vector<Population> population\_state\_}} \`{e} un vettore di oggetti di tipo Population presenze nella parte privata della classe di nome \textbf{\texttt{population\_state\_}}. In questo verr\`{a} registrato lo sviluppo temporale di ciascuno dei tre gruppi di individui.\\

\textbf{\texttt{solve}} \`{e} una funzione membro della classe, presenze nella sua parte pubblica, che restituisce un oggetto di tipo Population e prende come argomenti un Population e un int const. Questo metodo serve per aggiornare i dati riguardanti le tre categorie nelle quali \`{e} suddivisa la popolazione.\\

\textbf{\texttt{approx}} \`{e} una funzione membro della classe, presenze nella sua parte pubblica, che restituisce un oggetto di tipo Population. Prende come argomenti un Population e un int const. Stabilisce un criterio di approssimazione che garantisca che le conversioni tra numeri double e int eseguite da \textbf{\texttt{solve}} avvengano in maniera tale da mantenere costante il numero totale di individui $N$.\\

\textbf{\texttt{correct}} \`{e} la funzione composta che applica \textbf{\texttt{approx}} a \textbf{\texttt{solve}}. Cos\`{i} corregge le approssimazioni svolte automaticamente in maniera tale che vengano rispettate i vincoli del modello. Restituisce un Population e accetta come argomenti un Populatione un int const. È dichiarata nella parte privata della classe. \\

\textbf{\texttt{Epidemic}} \`{e} il costruttore della classe che prende come argomento due parametri di tipo double. La sua utilit\`{a} \`{e} quella di inizializzare le variabili private della classe \textbf{\texttt{beta\_}} e \textbf{\texttt{gamma\_}}. \\

\textbf{\texttt{evolve}} \`{e} un metodo pubblico che prende come argomenti un oggetto di tipo Population e un int const e restituisce un vettore di oggetti di tipo Population. Ciascuno di essi rappresenta lo stato della popolazione in una determinata giornata, dunque l'intero vettore registra l'intera diffusione dell'epidemia.\\
%\item \textbf{\texttt{state}}, una funzione che restituisce lo stato della popolazione. 
% non so se tenere questa funzione perchè non so se serva, ricordiamoci che nel caso va tolta

Il tutto \`{e} racchiuso in un namespace di nome \textbf{\texttt{pf}}.

\subsection{epidemic.cpp}
In \textit{epidemic.cpp}, file sorgente, vengono definite le funzioni membro di seguito elencate.\\

 Si definisce il costruttore \textbf{\texttt{Epidemic}} che dipende dai due parametri \textbf{\texttt{beta}} e \textbf{\texttt{gamma}}. Tramite i throw si verifica che questi rientrino nei loro domini di appartenenza. In maniera analoga si appura che sia verificata la relazione $r_0=\frac{\beta}{\gamma}>1$, condizione necessaria per la crescita del numero di infetti. \\

\textbf{\texttt{correct}} \`{e} la funzione che applica il metodo \textbf{\texttt{approx}} all'oggetto calcolato da \textbf{\texttt{solve}}. \\

 La funzione \textbf{\texttt{solve}} calcola sulla base delle equazioni (1) come varia in una giornata il numero di individui all'interno di ciascuno dei tre raggruppamenti in cui \`{e} suddivisa la popolazione. Per fare ci\`{o}, riceve come primo argomento un oggetto di tipo Population denominato \textbf{\texttt{prev\_state}}. Per essere pi\`{u} chiari, in riferimento alle equazioni (1), i dati $S_{i-1}$, $I_{i-1}$ e $R_{i-1}$ sono espressi da \textbf{\texttt{prev\_state}}, mentre $S_i$, $I_i$ e $R_i$ vengono calcolati da \textbf{\texttt{solve}}. Le relazioni (1) restituiscono numeri decimali, per questo la funzione arrotonda i risultati tramite l'algoritmo della Standard Library round. Il secondo argomento richiesto da \textbf{\texttt{solve}} \`{e} il numero totale di individui nella popolazione $N=S+I+R$, calcolato in \textbf{\texttt{evolve}} all'esterno del loop. Tramite questa scelta, dato che $N$ \`{e} costante, non dovr\`{a} essere ricalcolato ad ogni iterazione dell'algoritmo finale. In pi\`{u} \`{e} in questa sezione del codice che si \`{e} inserito il controllo sul vincolo $S$, $I$, $R$ $\in \mathbb{N} $.
 \\

In \textbf{\texttt{approx}} viene implementato il criterio che consente di svolgere gli arrotondamenti in maniera tale che si rispettino i vincoli del modello SIR. Infatti il numero totale degli individui degli abitanti $N$ deve rimanere costante durante tutto il corso dell'esecuzione. Ipotizziamo che a partire da specifici parametri iniziali per una popolazione di $N=300$ abitanti, in una determinata giornata le leggi (1) diano i valori $S=266,7$, $I=13,6$ e $R=19,7$. La funzione \textbf{\texttt{solve}} approssima tutti i questi dati per eccesso, cos\`{i} essi diventano $S=267$, $I=14$ e $R=20$. La loro somma a questo punto diventerebbe $tot=301\neq N$, ma \`{e} evidente che un tale risultato non pu\`{o} essere accettato. L'algoritmo elaborato riduce i guariti della differenza tra il totale e $N$ qualora il totale sia maggiore di $N$, mentre aggiunge agli infetti la loro differenza nel caso in cui il totale sia minore di $N$. \\

In \textbf{\texttt{evolve}} viene implementato l'algoritmo chiave di tutto il programma. Innanzitutto viene aggiunto al vettore \textbf{\texttt{population\_state\_}} la suddivisione iniziale della popolazione, registrata come elemento di tipo Population, \textbf{\texttt{initial\_population}}, tramite il metodo fornito dalla Standard Library \textit{push.back}. Si calcola il numero totale $N$ degli individui tramite le informazioni riguardanti lo stato iniziale della popolazione.
Si avvia quindi un ciclo for che esegue tante iterazioni quante indicate dall'argomento $\textbf{\texttt{time}} + 1$ (il conteggio prende inizio dalla giornata 0, pertanto si deve ottenere un campione di suddivisioni pari al numero di giorni dall'inizio dell'epidemia +1). Per non sovrascrivere l'oggetto di tipo Population che esprime la suddivisione del giorno precedente, all'inizio di ogni loop viene creato un nuovo oggetto dello stesso tipo a cui vengono attribuiti i valori calcolati dalla funzione \textbf{\texttt{correct}}. Infine esso viene aggiunto a \textbf{\texttt{population\_state\_}}. Conclusi i loop, \textbf{\texttt{evolve}} restituisce il vettore completo.

%scrivere la parte di definizione della funzioe graphic
\subsection{epidemic.test.cpp}
Il file \textit{epidemic.test.cpp} \`{e} quello responsabile dell'esecuzione dei test. Per fare ci\`{o} bisogna inserire in shell i comandi
\begin{itemize}
\item 
\textbf{cmake -S . -B build -DCMAKE\_BUILD\_TYPE=Debug} e 
    \textbf{cmake --build build} per compilare.  %da verificare
\item \textbf{cmake --build build --target test} per eseguire i test.
\end{itemize}
Raccolti in un primo TEST\_CASE, i primi quattro test verificano i corretto funzionamento dei throw nel caso in cui $\beta$ e $\gamma$ non rientrino nei rispettivi limiti di esistenza e per quando $r_0=\frac{\beta}{\gamma}>1$.  \\

In un secondo TEST\_CASE si testano le funzioni \textbf{\texttt{solve}} e \textbf{\texttt{approx}}. Si testa la funzione \textbf{\texttt{solve}} nel caso in cui tutti e tre i parametri che descrivono la popolazione devono essere approssimati per eccesso, e nel caso in cui tutti vengono approssimati per difetto. Agli stessi due sistemi si applica la funzione \textbf{\texttt{approx}}, cos\`{i} da confermare il giusto funzionamento dell'algoritmo elaborato. \\

Infine, in un ultimo TEST\_CASE si esegue un test su un sistema per cui $N=300$ e $r_0 \rightarrow 1$ ed uno dove  $N=300$ e $\beta >> \gamma$. Si verifica la compatibilit\`{a} dei dati calcolati dal programma con quelli calcolati tramite un foglio di calcolo Excel per i giorni da 0 a 4 e da 13 a 15. 
\subsection{main.hpp}
Il file \textit{main.cpp} consente di eseguire il programma, inserendo i seguenti comandi su shell 
%verifica che sia giusto!!!!
\begin{itemize}
\item \texttt{\textbf{cmake -S . -B build -DCMAKE\_BUILD\_TYPE=Debug}} e \texttt{\textbf{cmake --build build}} per compilare  %da sistemare
\item \texttt{\textbf{./build/epidemic}} per eseguire
\end{itemize}
I parametri iniziali possono essere presi da file di configurazione, da standard input o da riga di comando. Per ciascuno di essi, il file main richiede di inserire un apposito carattere:
\begin{itemize}
\item \textbf{\texttt{l}} i parametri sono stabiliti di default su riga di comando e valgono $\beta = 0.8$, $\gamma = 0.4$, $S_0 = 997$, $I_0 = 3$, $R_0 = 0$, $day = 40$.
\item \textbf{i} riceve i dati di partenza da standard input.
\item \textbf{\texttt{f}} seguito da \texttt{FILE NAME} legge i valori dei parametri iniziali salvati sul file indicato. In esso i valori devono essere collocati nel seguente ordine $\beta$, $\gamma$, $S_0$, $I_0$, $R_0$, $day$. Se l'ordine non viene rispettato, i valori letti vengono interpretati secondo significati diversi rispetto al loro proprio ed il risultato ottenuto non sar\`{a} quello cercato.
\item \textbf{\texttt{q}} chiude il programma.
\end{itemize}
L'output del programma è costituito da una tabulazione dei valori di $day$, $S$, $I$ e $R$ su standard output, così da registrare la variazione di individui facenti parte ciascun raggruppamento nell'arco di una giornata. \\

In Table 1 si riporta un esempio di output ottenuto utilizzando come valori in input quelli salvati su riga di comando. 
%aggiungere un esempio della schermata di output da processo l
\begin{center}
\textit{Report for each of the stored states of population:}
\begin{table}[htbp]
  \centering
\begin{tabular}{c c c c}
 day & S & I & R \\
 \hline
  0	& 997	&3&	0\\
1	&995	&4	&1\\
2	&991	&6	&3\\
3&	987&	8&	5\\
4	&980&	12	&8\\
5	&971&	16&	13\\
6&	959&	22&	19\\
7&	943&	30&	27\\
8&	920	&40&	40\\
9&	891	& 53	&56\\
10&	853& 70&	77\\
...
\end{tabular}
\caption{Output ottenuto a partire dai dati registrati in riga di comando dove $\beta = 0.8$, $\gamma = 0.4$, $S_0 = 997$, $I_0 = 3$, $R_0 = 0$, $day = 40$.}\label{etichetta}
  \medskip
\end{table}
\end{center}}
In chiusura di ciascuna esecuzione, si d\`{a} la possibilit\`{a} di graficare l'andamento delle tre variabili S, I e R attraverso il comando \texttt{\textbf{g}}. Qualsiasi altro comando consente di tornare alla schermata iniziale, dove si può scegliere se avviare una nuova simulazione o chiudere il programma. Nel grafico ottenuto, sull'asse delle ascisse è collocato il tempo in giorni, mentre su quello delle ordinate, il numero di individui. Le tre curve, di colore blu, rosso e verde, rappresentano rispettivamente la variazione dei parametri S, I, e R.\\

In Figure 1 si riporta un esempio di grafico ottenuto utilizzando come valori in input quelli salvati su riga di comando. 
%inserire grafico e fare piccola descrizione come per le relazioni di lab
%\includegraphics{grafico}  
\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\textwidth]{mesh}
    \caption{Grafico realizzato sulla base del procedimento avviato col comando \textbf{l}, dove i parametri iniziali valgono  $\beta = 0.8$, $\gamma = 0.4$, $S_0 = 997$, $I_0 = 3$, $R_0 = 0$, $day = 40$. Sull'asse delle ascisse è collocato il tempo in giorni, su quello delle ordinate il numero di individui. Le tre curve, di colore blu, rosso e verde, rappresentano rispettivamente la variazione dei parametri S, I, e R.}
    \label{fig:mesh1}
\end{figure}

\section{Conclusione}


\end{document}
